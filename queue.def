#include <pthread.h>
#include <string.h>
#include "err.h"
#include "queue.dec"

#define SHRINK_FACTOR 4

int CONCAT(PREFIX_, _queue_init)(QUEUE_TYPE_ *const q, size_t max_size) {
    q->capacity = 16;
    q->beg = 0;
    q->end = 0;
    q->size = 0;
    q->max_size = max_size;
    q->buffer = malloc(sizeof(TYPE_) * q->capacity);
    if (q->buffer == NULL)
        return -1;
    return 0;
}

int CONCAT(PREFIX_, _queue_push)(QUEUE_TYPE_ *const q, TYPE_ elem) {
    int err;
    verify(pthread_mutex_lock(&q->mutex), "mutex unlock failed");
    if (q->size == ACTOR_QUEUE_LIMIT) {
        verify(pthread_mutex_unlock(&q->mutex), "mutex unlock failed");
        return -2;
    }
    if (q->size == q->capacity) {
        q->capacity *= 2;
        q->buffer = realloc(q->buffer, sizeof(TYPE_) * q->capacity);
        if (q->buffer == NULL)
            return -1;

        // TODO: should it work anyhow???
//        for (size_t i = 0; i < q->beg; ++i) {
//            q->buffer[q->capacity / 2 + i] = q->buffer[i];
//        }
        memcpy(q->buffer + q->capacity / 2, q->buffer, q->beg * sizeof(TYPE_));
        q->end = q->beg + q->size;

        /*for (size_t i = q->beg, j = 0; i != q-> beg; i = (i + 1) % q->capacity / 2, ++j) {

        }*/
    }

    q->buffer[q->end] = elem;
    q->end = (q->end + 1 % q->capacity);
    ++q->size;
    verify(pthread_mutex_unlock(&q->mutex), "mutex unlock failed");
    return 0;
}

int CONCAT(PREFIX_, _queue_pull)(QUEUE_TYPE_ *const q, TYPE_ *const elem) {
    int err;
    verify(pthread_mutex_lock(&q->mutex), "mutex unlock failed");
    if (q->size == 0) {
        verify(pthread_mutex_unlock(&q->mutex), "mutex unlock failed");
        return -2;
    }

    *elem = q->buffer[q->beg];
    q->beg = (q->beg + 1 % q->capacity);
    --q->size;
    if (q->size * SHRINK_FACTOR < q->capacity &&
        q->beg * 2 < q->capacity && q->end * 2 < q->capacity) {
        q->capacity /= 2;
        q->buffer = realloc(q->buffer, sizeof(TYPE_) * q->capacity);
        if (q->buffer == NULL)
            return -1;
    }
    verify(pthread_mutex_unlock(&q->mutex), "mutex unlock failed");
    return 0;
}
