#include <string.h>
#include <errno.h>
#include "queue.dec"
#include "err.h"

#define SHRINK_FACTOR 4
#define INITIAL_CAPACITY 8

int CONCAT(PREFIX_, _queue_init)(QUEUE_TYPE_ *const q, size_t max_size) {
    q->capacity = INITIAL_CAPACITY;
    q->beg = 0;
    q->end = 0;
    q->size = 0;
    q->max_size = max_size;
    q->buffer = malloc(sizeof(TYPE_) * q->capacity);
    if (q->buffer == NULL)
        return -1;
    return 0;
}

void CONCAT(PREFIX_, _queue_push)(QUEUE_TYPE_ *const q, TYPE_ elem) {
    if (q->size == q->max_size) {
        fatal("maximum queue size reached");
    }
    if (q->size == q->capacity) {
        q->capacity *= 2;
        q->buffer = realloc(q->buffer, sizeof(TYPE_) * q->capacity);
        if (q->buffer == NULL)
            fatal("realloc failed");

        // TODO: should it work anyhow???
//        for (size_t i = 0; i < q->beg; ++i) {
//            q->buffer[q->capacity / 2 + i] = q->buffer[i];
//        }
        memcpy(q->buffer + q->capacity / 2, q->buffer, q->beg * sizeof(TYPE_));
        q->end = (q->beg + q->size) % q->capacity;
    }
    q->buffer[q->end] = elem;
    q->end = ((q->end + 1) % q->capacity);
    ++(q->size);
}

TYPE_ CONCAT(PREFIX_, _queue_pop)(QUEUE_TYPE_ *const q) {
    if (CONCAT(PREFIX_, _queue_is_empty)(q))
        fatal("Attempted pop from an empty queue.");

    TYPE_ elem = q->buffer[q->beg];
    q->beg = ((q->beg + 1) % q->capacity);
    --q->size;
    if (q->capacity > INITIAL_CAPACITY && q->size * SHRINK_FACTOR < q->capacity &&
        q->beg * 2 < q->capacity && q->end * 2 < q->capacity) {
        q->capacity /= 2;
        q->buffer = realloc(q->buffer, sizeof(TYPE_) * q->capacity);
        if (q->buffer == NULL)
            fatal("realloc failed");
    }
    return elem;
}
